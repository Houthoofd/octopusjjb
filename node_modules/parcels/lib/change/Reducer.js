'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

exports.default = MultiReducer;

var _butLast = require('unmutable/lib/butLast');

var _butLast2 = _interopRequireDefault(_butLast);

var _isEmpty = require('unmutable/lib/isEmpty');

var _isEmpty2 = _interopRequireDefault(_isEmpty);

var _last = require('unmutable/lib/last');

var _last2 = _interopRequireDefault(_last);

var _pipe = require('unmutable/lib/util/pipe');

var _pipe2 = _interopRequireDefault(_pipe);

var _pipeWith = require('unmutable/lib/util/pipeWith');

var _pipeWith2 = _interopRequireDefault(_pipeWith);

var _delete = require('../parcelData/delete');

var _delete2 = _interopRequireDefault(_delete);

var _insertAfter = require('../parcelData/insertAfter');

var _insertAfter2 = _interopRequireDefault(_insertAfter);

var _insertBefore = require('../parcelData/insertBefore');

var _insertBefore2 = _interopRequireDefault(_insertBefore);

var _pop = require('../parcelData/pop');

var _pop2 = _interopRequireDefault(_pop);

var _push = require('../parcelData/push');

var _push2 = _interopRequireDefault(_push);

var _set = require('../parcelData/set');

var _set2 = _interopRequireDefault(_set);

var _setSelf = require('../parcelData/setSelf');

var _setSelf2 = _interopRequireDefault(_setSelf);

var _shift = require('../parcelData/shift');

var _shift2 = _interopRequireDefault(_shift);

var _swap = require('../parcelData/swap');

var _swap2 = _interopRequireDefault(_swap);

var _swapNext = require('../parcelData/swapNext');

var _swapNext2 = _interopRequireDefault(_swapNext);

var _swapPrev = require('../parcelData/swapPrev');

var _swapPrev2 = _interopRequireDefault(_swapPrev);

var _unshift = require('../parcelData/unshift');

var _unshift2 = _interopRequireDefault(_unshift);

var _updateIn = require('../parcelData/updateIn');

var _updateIn2 = _interopRequireDefault(_updateIn);

var _updateChild = require('../parcelData/updateChild');

var _updateChild2 = _interopRequireDefault(_updateChild);

var _updateChildKeys = require('../parcelData/updateChildKeys');

var _updateChildKeys2 = _interopRequireDefault(_updateChildKeys);

var _Action = require('./Action');

var _Action2 = _interopRequireDefault(_Action);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function MultiReducer(parcelData, action) {
    var actionArray = Array.isArray(action) ? action : [action];
    var reduced = actionArray.reduce(Reducer, parcelData);
    return (0, _extends3.default)({
        value: undefined,
        meta: {}
    }, reduced);
}

function Reducer(parcelData, action) {
    if (!(action instanceof _Action2.default)) {
        throw new Error('Reducer must receive an Action');
    }

    var keyPath = action.keyPath,
        _action$payload = action.payload,
        value = _action$payload.value,
        meta = _action$payload.meta,
        type = action.type;


    var keyPathLast = (0, _last2.default)()(keyPath);
    var keyPathButLast = (0, _butLast2.default)()(keyPath);
    var keyPathIsEmpty = (0, _isEmpty2.default)()(keyPath);

    var updateIn = function updateIn(keyPath, updater) {
        return (0, _pipeWith2.default)(parcelData, (0, _updateIn2.default)(keyPath, (0, _pipe2.default)((0, _updateChild2.default)(), (0, _updateChildKeys2.default)(), updater)));
    };

    switch (type) {
        case "delete":
            {
                if (keyPathIsEmpty) {
                    throw new Error('Delete actions must have a keyPath with at least one key');
                }
                return updateIn(keyPathButLast, (0, _delete2.default)(keyPathLast));
            }

        case "insertAfter":
            {
                if (keyPathIsEmpty) {
                    throw new Error('InsertAfter actions must have a keyPath with at least one key');
                }
                return updateIn(keyPathButLast, (0, _insertAfter2.default)(keyPathLast, { value: value }));
            }

        case "insertBefore":
            {
                if (keyPathIsEmpty) {
                    throw new Error('InsertBefore actions must have a keyPath with at least one key');
                }
                return updateIn(keyPathButLast, (0, _insertBefore2.default)(keyPathLast, { value: value }));
            }

        case "ping":
            {
                return parcelData;
            }

        case "pop":
            {
                return updateIn(keyPath, (0, _pop2.default)());
            }

        case "push":
            {
                return updateIn(keyPath, (0, _push2.default)({ value: value }));
            }

        case "set":
            {
                if (keyPathIsEmpty) {
                    return (0, _setSelf2.default)({ value: value })(parcelData);
                }

                return updateIn(keyPathButLast, (0, _set2.default)(keyPathLast, { value: value }));
            }

        case "setMeta":
            {
                if (keyPathIsEmpty) {
                    return (0, _setSelf2.default)({ meta: meta })(parcelData);
                }

                return updateIn(keyPathButLast, (0, _set2.default)(keyPathLast, { meta: meta }));
            }

        case "shift":
            {
                return updateIn(keyPath, (0, _shift2.default)());
            }

        case "swap":
            {
                if (keyPathIsEmpty) {
                    throw new Error('Swap actions must have a keyPath with at least one key');
                }
                var swapKey = action.payload.swapKey;

                if (typeof swapKey === "undefined") {
                    throw new Error('Swap actions must have a swapKey in their payload');
                }

                return updateIn(keyPathButLast, (0, _swap2.default)(keyPathLast, swapKey));
            }

        case "swapNext":
            {
                if (keyPathIsEmpty) {
                    throw new Error('SwapNext actions must have a keyPath with at least one key');
                }

                return updateIn(keyPathButLast, (0, _swapNext2.default)(keyPathLast));
            }

        case "swapPrev":
            {
                if (keyPathIsEmpty) {
                    throw new Error('SwapPrev actions must have a keyPath with at least one key');
                }

                return updateIn(keyPathButLast, (0, _swapPrev2.default)(keyPathLast));
            }

        case "unshift":
            {
                return updateIn(keyPath, (0, _unshift2.default)({ value: value }));
            }
    }

    throw new Error('"' + action.type + '" is not a valid action');
}